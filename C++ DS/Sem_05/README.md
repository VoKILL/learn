## Задачи

**Задача 1:** Даден е масив от цели числа.  
Напишете функция, която работи за **O(n)** време и **O(1)** памет и пренареджда елементите, така че *всяко отрицателно число да е преди всяко положително число*.  
*Вход: 3 6 -5 -1 5, Изход: -1 -5 6 3 5*  

**Задача 2:** Даден е масив от цели числа. За този масив са изпълнени следните условия:  
-  За всяко  i, k: Ако i < k, arr[i] и arr[k] са  **четни**, то arr[i] <= arr[k].  
-  За всяко  i, k: Ако i < k, аrr[i] и arr[k] са  **нечетни**, то arr[i] >= arr[k].  

Напишете функция, която *сортира масива за време **O(n)***.  
*Вход: 2 5 8 3 12 14 20 1, Изход: 1 2 3 5 8 12 14 20*  

**Задача 3:** Напишете функция, която приема масив от цели числа и проверява дали подредицата, съставена само от положителните числа в масива е същата като подредицата, съставена от отрицателните числа в масива (след умножаването на всички числа в едната подредица с -1).  
**Да се реши чрез опашка!**  

*Вход: 1 5 -1 4 -5 9 8 -4 -9 18 -8 -18 -7 7, Изход: true  
Вход: 1 -1 2 -2 3 3, Изход: false*  

**Задача 4:** Даден е списък **l** с елементи списъци от естествени числа в интервала [0,..,9]. От всеки списък l_i получаваме две числа по следния начин:  
- Обхождайки го отпред назад, получваме число n_i.  
- Обхождайки го отзад напред, получаваме число n_i_reversed.  

Да се дефинира функция, която *намира сумата n_i + n_i_reversed за 0 <= i <= l.size() - 1*.  

*Вход:* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Изход:*
```c++
1 -> 2                        809
|                             (12 + 21 + 234 + 432 + 55 + 55)
v
2 -> 3 -> 4
|
v
empty
|
v
5 -> 5
```

**Задача 5 (Контролно 2021):** Даден е списък **l** с n елемента.  
Да се дефинира функция *shuffle()*, която получава адреса на първия елемент на списъка. Функцията да пренарежда възлите на списъка така, че *елементите от втората половина на списъка да се преместят в началото на списъка, но в обратен ред* (при списъци с нечетен брой елементи считаме средния елемент за принадлежащ към първата половина на списъка).  

*Пример:*
*L1 → L2 → L3 → L4 → L5 се преобразува до L5 → L4 → L1 → L2 → L3*  

**Задача 6 (Контролно 2021):** Даден е списък **l** с елементи стекове.  
Да се дефинира функция *equalize(l)*, която размества елементите на стековете така, че *да няма два стека в l с разлика в броя на елементите, по-голяма от 1*.  

*Пример:*  
*Вход:* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*Изход:*
```c++
5 -> 4 -> 3 -> 2 -> 1         5 -> 4 -> 3
|                             |
v                             v
7 -> 6                        7 -> 6 -> 1
|                             |
v                             v
11 -> 10 -> 9 -> 8            11 -> 10 -> 9
|                             |
v                             v
12                            12 -> 2 -> 8
```
