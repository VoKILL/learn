# Свързан списък

Структурата данни *"Свързан списък"* представлява поредица от елементи, като всеки от тях съдържа не само информацията, която бихме пазили в масив, ами и информация кой е *следващият (и предишният)* елемент в поредицата.  
В най-стандартната имплементация, тази информация представлява указател към следващия (и предишния) елемент. Така лесно можем да обходим всички елементи от структурата - започвайки от първия, следваме неговия указател към следващия, от там към по-следващия и т.н.  
Допълнително ще пазим два указателя - към първия и към последния елемент на списъка. Това ще ни позволява лесно да добавяме елемент както в началото, така и в края на списъка.  
 
 ## Едносвързан списък (Singly Linked List)

![alt text](https://i.ibb.co/37WN76n/SLL.png)

 ### Сложност на операциите му:  
 - Добавяне на елемент на произволна позиция -> **O(n)**.  
В частност, добавяне на елемент в началото/края -> **O(1)**.  
-  Премахване на елемент от произволна позиция -> **O(n)**.   
В частност, премахване на елемент от началото -> **O(1)**.  
- "Преглед" на произволен елемент -> **O(n)**.  
В частност, в началото и в края  -> **O(1)**.  

 ## Двусвързан списък (Doubly Linked List)
  ### Сложност на операциите му:  
 - Добавяне на елемент на произволна позиция -> **O(n)**.  
В частност, добавяне на елемент в началото/края -> **O(1)**.  
-  Премахване на елемент от произволна позиция -> **O(n)**.   
В частност, премахване на елемент от началото/края -> **O(1)**.  
- "Преглед" на произволен елемент -> **O(n)**.  
В частност, в началото и в края  -> **O(1)**.  

Тук се появява и най-големият недостатък на списъците в сравнение с динамичния масив.  
**При списъците губим възможността за директен достъп**.  Няма начин, по който да индексираме k-тия елемент, без да минем през всички k-1 предходни.  

## LinkedStack

В предишната тема видяхме, че можем да реализираме АДТ Стек
**чрез динамичен масив** (*push_back && pop_back*).  
Как можем да реализираме стек чрез **едносвързан списък**?  
- Вариант 1:  
*push_back && pop_back*   
- Варинат 2:  
*push_front && pop_front*  

| |push_back|pop_back||  
|--|--|--|--|  
|Вектор|O(1)|O(1)|:heavy_check_mark:|  
|Едносвързан списък|O(1)|O(n)|:x:|  
|Двусвързан списък|O(1)|O(1)|:x:|  

| |push_front|pop_front||  
|--|--|--|--|  
|Вектор|O(n)|O(n)|:x:|  
|Едносвързан списък|O(1)|O(1)|:heavy_check_mark:|  
|Двусвързан списък|O(1)|O(1)|:x:|  

# Опашка (Queue)

Абстрактен тип данни, базиран на принципа **"First In First Out (FIFO)"**.  
Обектите се добавят и премахват от **противополжни** страни (за сравнение, при стека се добавят и премахват от **една и съща** страна).  
Опашката има три операции:  
-  **enqueue** – добавя нов елемент от едната страна  
-  **dequeue** – премахва елемент от противоположната страна  
- **peek** – достъп до първия елемент на опашката  

![alt text](https://i.ibb.co/9h5DGkw/Queue.png)

## Реализация на опашка
- Вариант 1:  
*push_back && pop_front*   
- Варинат 2:  
*push_front && pop_back*  

| |push_back|pop_front||  
|--|--|--|--|  
|Вектор|O(1)|O(n)|:x:|  
|Едносвързан списък|O(1)|O(1)|:heavy_check_mark:|  
|Двусвързан списък|O(1)|O(1)|:x:|  

| |push_front|pop_back||  
|--|--|--|--|  
|Вектор|O(n)|O(1)|:x:|  
|Едносвързан списък|O(1)|O(n)|:x:|  
|Двусвързан списък|O(1)|O(1)|:x:|  
