# Графи (Graphs)

## Видове графи:
- ориентиран / неориентиран  
- тегловен / нетегловен  
- обикновен граф / мултиграф  

## Основни операции:
Графите (като абстрактен тип данни) трябва да поддържат (част) от следните операции:  

- **addVertex** - добавяне на нов връх  
- **removeVertex** - премахване на връх  
- **addEdge** - добавяне на ново ребро  
- **removeEdge** - премахване на ребро  
- **getSuccessors** - взимане на наследниците на връх (при ориентирани графи)  
- **getPredecessors** - взимане на предшествениците на връх (при ориентирани графи)  
- **adjacent** - взимане на съседните върхове на даден връх (при неориентирани графи)  

## Представяне на графи:
Графите могат да се представят по различен начин в зависимост от това  ***какъв граф ни трябва и какви са целите ни.***  Реализация на граф ***за общо предназначение няма***. Това е и причината в стандартната библиотека (stl) да нямаме структура граф.  

### 1. Матрица на съседство (Adjacency matrix):

В клетка M[i][j] е записано теглото на реброто от връх i до връх j, ако има такова, или 0, ако няма такова.  

![alt_text](https://i.ibb.co/TBw1T2t/Adj-matrix.png)

|Операция|Сложност||
|--|--|--|
|addVertex|O(n)||
|removeVertex|O(n)||
|addEdge|O(1)|:heavy_check_mark:|
|removeEdge|O(1)|:heavy_check_mark:|
|getSuccessors|O(n)||
|getPredecessors|O(n)||

**Памет** - O(n^2) :x:  

*Забележка 1:* Тази реализация не ни дава възможност да поддържаме мултиграфи.  
*Забележка 2:* Тази реализация не ни позволява да имаме ребро с тегло 0 (двусмислие - нямаме ребро или ~~имаме ребро с тегло 0~~).  

### 2. Списък на съседство (Adjacency list):

Всеки връх v пази списък с върховете, към които сочат ребрата, излизащи от v. Ако графът е тегловен, към всеки връх от списъка с наследниците се добавя допълнително поле, показващо цената на реброто до него.  

![alt_text](https://i.ibb.co/yPPp6Ds/adj-List-Graph.jpg)

|Операция|Сложност||
|--|--|--|
|addVertex|O(1)|:heavy_check_mark:|
|removeVertex|O(n+m)||
|addEdge|O(1)|:heavy_check_mark:|
|removeEdge|O(m)||
|getSuccessors|O(m)||
|getPredecessors|O(n+m)||

**Памет** - O(n+m) :heavy_check_mark:  

### 3. Списък на ребра (Edge list):

Представя се чрез списък от всички наредени двойки <v_i, v_j>, за които е вярно, че има ребро от v_i до v_j. Ако графът е тегловен, то вместо наредени двойки поддържаме наредени тройки с трети елемент - теглото на даденото ребро.  

![alt_text](https://i.ibb.co/yVS2sBM/edge-List-Graph.jpg)

|Операция|Сложност||
|--|--|--|
|addVertex|O(1)|:heavy_check_mark:|
|removeVertex|O(m)||
|addEdge|O(1)|:heavy_check_mark:|
|removeEdge|O(m)||
|getSuccessors|O(m)||
|getPredecessors|O(m)||

**Памет** - O(m) :heavy_check_mark:  

## Алгоритми върху графи:
- Обхождане в ширина (**BFS**)  
- Обхождане в дълбочина (**DFS**) - Итеративно  
- Обхождане в дълбочина (**DFS**) - Рекурсивно  
- Проверка дали граф е **двуделен**  
- **Dijkstra**'s algorithm  
