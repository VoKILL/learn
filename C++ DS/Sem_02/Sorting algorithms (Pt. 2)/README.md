# Рекурсивни сортиращи алгоритми

## ***Merge sort***
Рекурсивен сортиращ алгоритъм, изграден по алгоритмичната схема "**Разделяй и владей**".
![alt text](https://i.ibb.co/xm8Sc5n/Merge-sort.png)
- Рекурентното уравнение, описващо работата на MergeSort, e:  
**T(n) = 2T(n/2) + n**.  
Това рекурентно уравнение се решава чрез Мастър теоремата ("**Master theorem**") и асимптотиката на решението му, даваща ни сложността по време на Merge sort (B.-C. = A.-C. = W.-C.), е **nlog(n)**.
 
## ***Quick sort***
Рекурсивен сортиращ алгоритъм, изграден по алгоритмичната схема "**Разделяй и владей**".
![alt text](https://i.ibb.co/fYsPFwL/Quick-sort.png)
- Рекурентното уравнение, описващо работата на MergeSort **в най-добрия и в средния случай** (Когато пивотът е средният по големина елемент или близко до средния), e:  
**T(n) = 2T(n/2) + n** -> (Master theorem) -> **nlog(n)**.  
- Рекурентното уравнение, описващо работата на MergeSort **в най-лошия случай** (Когато пивотът е най-малкият или най-големият по големина елемент), e:  
**T(n) = T(n - 1) + n**. -> (Методът на хар. ур-е) -> **n^2**  

||Merge sort|Quick sort|  
|--|--|--|  
|Най-добър случай (Best case) |O(nlog(n)) |O(nlog(n)) |  
|Среден случай (Average case) |O(nlog(n)) |O(nlog(n)) |  
|Най-лош случай (Worst case) |O(nlog(n)) |O(n^2) |  
|Памет |O(n) |O(1) |  
|Стабилност |:heavy_check_mark: |:x: |  
|Недостатъци |Допълнителна памет| Възможност за квадратична по време сложност |


**Теорема** - Не съществува сортиращ алгоритъм, **базиран на директни сравнения**, който в най - лошия случай прави < nlog(n) стъпки.  

## Сортиране в линейно време. Counting sort.  
Сортирането на **прозволни** елементи, чиито индивидуални стойности не можем четем, а само можем да сравняваме елементите един с друг, не може да става асимптотично по-бързо от nlog(n). Но тази долна граница не е в сила, ако има някакви **ограничения за възможните стойности на елементите**.  

Пример за сортиращ алгоритъм, който работи за време O(n) е Counting sort (Или така нареченият, "Сортиране чрез броене").  
Най - общо казано, алгоритъмът обхожда елементите, създавайки хистограма на броя пъти, в които даден ключ се среща във входните данни.  
След това за всеки елемент от входния масив се определя позиция, на която трябва да бъде поставен в изходния масив.  
Накрая елементите се обхождат отново, като се преместват на сортираните позиции в изходния масив.  

||Counting sort|  
|--|--|  
|Най-добър случай (BC) |O(n + m) |  
|Среден случай (AC) |O(n + m) | 
|Най-лош случай (WC) |O(n + m) | 
|Памет |O(n + m) | 
|Стабилност |:heavy_check_mark: |
